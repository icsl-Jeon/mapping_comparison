<?xml version="1.0" encoding="UTF-8"?>
<launch>
  <arg name="mav_name" default="firefly"/>
  <arg name="target_name" default="target"/>
  <arg name="world_name" default="map3"/>
  
	<arg name="target_x" default="0.0"/>
	<arg name="target_y" default="0.0"/>
	<arg name="mav_x" default="6.0"/>
	<arg name="mav_y" default="1.0"/>
	<arg name="mav_z" default="1.0"/>



  <!--Octomap bt file path if any-->
  <!--If we are going to load pre-existing map from bt file-->
  <!--Else, we build from sensor-->
  <arg name="bt_name" default="$(arg world_name)"/>

  <arg name="enable_logging" default="false" />
  <arg name="enable_ground_truth" default="false" />
  <arg name="log_file" default="$(arg mav_name)" />  
  
  <env name="GAZEBO_MODEL_PATH" value="${GAZEBO_MODEL_PATH}:$(find rotors_gazebo)/models"/>
  <env name="GAZEBO_RESOURCE_PATH" value="${GAZEBO_RESOURCE_PATH}:$(find rotors_gazebo)/models"/>
   
   
     <!-- world generation -->

    <include file="$(find gazebo_ros)/launch/empty_world.launch">
    <arg name="world_name" value="$(find traj_gen_chasing)/worlds/$(arg world_name).world" />
    <arg name="paused" value="false"/> <!--if this enabled, ros time paused also-->
    <arg name="gui" value="false"/> 
    </include>


    
     <!--target spawn at defined position -->
		
	<!-- <group ns ="$(arg target_name)">
	<include file="$(find turtlebot_gazebo)/launch/includes/kobuki.launch.xml">
		<arg name="base" value="kobuki"/>
		<arg name="stacks" value="hexagons"/>
		<arg name="robot_name" value="target"/>	 
		<arg name="3d_sensor" value="kinect"/>
		<arg name="init_pose" value="-x $(arg target_x) -y $(arg target_y)"/>
	</include> -->



	<!-- <node pkg="turtlebot_teleop" type="turtlebot_teleop_key" name="turtlebot_teleop_keyboard"  output="screen" launch-prefix="xterm -e">
		<param name="scale_linear" value="0.5" type="double"/>
		<param name="scale_angular" value="1.5" type="double"/>
		<remap from="turtlebot_teleop_keyboard/cmd_vel" to="cmd_vel_mux/input/teleop"/>
	</node> -->

	<!-- </group> -->


     <!-- group name/MAV spawn at origin -->

	<group ns ="$(arg mav_name)">
    <include file="$(find rotors_gazebo)/launch/spawn_mav.launch">
      <arg name="mav_name" value="$(arg mav_name)" />
      <arg name="model" value="$(find rotors_description)/urdf/mav_with_vi_sensor.gazebo"/>
      <arg name="enable_logging" value="$(arg enable_logging)" />
      <arg name="enable_ground_truth" value="$(arg enable_ground_truth)" />
      <arg name="x" value="1.0" />
      <arg name="y" value="0.0" />
	  <arg name="z" value="2.0" />

      <arg name="log_file" value="$(arg log_file)"/>
	</include>

	<!--state_publisher-->
    <node name="robot_state_publisher" pkg="robot_state_publisher" type="robot_state_publisher" />
    <node name="joint_state_publisher" pkg="joint_state_publisher" type="joint_state_publisher" />
    
	<!--controller-->
    <node name="lee_position_controller_node" pkg="rotors_control" type="lee_position_controller_node" output="screen">
      <rosparam command="load" file="$(find rotors_gazebo)/resource/lee_controller_$(arg mav_name).yaml" />
      <rosparam command="load" file="$(find rotors_gazebo)/resource/$(arg mav_name).yaml" />
      <remap from="odometry" to="odometry_sensor1/odometry" />
	  
    </node>	
	</group>
	
	<!-- voxblox  -->
	<include file = "$(find mav_mapping_comp)/launch/voxblox_mav_gazebo.launch"/>
	


	<!-- tf mapping -->
	<include file = "$(find gazebo2rviz)/launch/gazebo2tf.launch"/>

	<group ns = "tf_mapping">
		<node pkg="tf" type="static_transform_publisher" name="tf_mapper_mav" args="0 0 0 0 0 0 /$(arg mav_name)__$(arg mav_name)/base_link /$(arg mav_name)/base_link 100" />
		<node pkg="tf" type="static_transform_publisher" name="tf_mapper_target" args="0 0 0 0 0 0 /$(arg target_name)__base_footprint /$(arg target_name)/base_footprint 100" />
	</group>



 	<node name="rviz" pkg="rviz" type="rviz" args="-d $(find mav_mapping_comp)/rviz/voxblox.rviz"/>

</launch>
